generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum GovernmentScope {
  MUNICIPAL
  STATE
  FEDERAL
}

model User {
  id               String    @id @default(uuid()) @db.Uuid
  email            String    @unique
  clerkUserId      String?   @unique
  /// Phone number; required for checkout. Used to contact the user after a refund (e.g. for feedback).
  phone            String?
  /// Stripe Customer ID; set when the user completes checkout or when we create a customer for them.
  stripeCustomerId String?   @unique
  createdAt        DateTime  @default(now())

  attempts          Attempt[]
  exams             Exam[]
  examBaseAttempts  ExamBaseAttempt[]
  purchases         Purchase[]
  refundRequests    RefundRequest[]
  trainingSessions  TrainingSession[]

  @@map("users")
}

model Skill {
  id        String     @id @default(uuid()) @db.Uuid
  name      String
  createdAt DateTime   @default(now())

  // Path Enumeration (Materialized Path)
  // Stores the complete hierarchy (ex: "uuid1/uuid2/uuid3")
  path String @unique

  parentId  String?    @db.Uuid
  parent    Skill?     @relation("SkillHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  Skill[]    @relation("SkillHierarchy")

  questions Question[]

  @@map("skills")
  @@index([path])
}

model Question {
  id              String    @id @default(uuid()) @db.Uuid
  statement       String
  explanationText String
  createdAt       DateTime  @default(now())

  skillId String @db.Uuid
  skill   Skill  @relation(fields: [skillId], references: [id], onDelete: Restrict)

  options       Option[]
  attempts      Attempt[]
  examQuestions ExamQuestion[]

  @@index([skillId])
  @@map("questions")
}

model Option {
  id        String   @id @default(uuid()) @db.Uuid
  text      String
  isCorrect Boolean
  createdAt DateTime @default(now())

  questionId String   @db.Uuid
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  attempts Attempt[]

  @@index([questionId])
  @@map("options")
}

model Attempt {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  examId String? @db.Uuid
  exam   Exam?   @relation(fields: [examId], references: [id], onDelete: SetNull)

  questionId String   @db.Uuid
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  selectedOptionId String? @db.Uuid
  selectedOption   Option? @relation(fields: [selectedOptionId], references: [id], onDelete: Restrict)

  @@index([userId, createdAt])
  @@index([examId, createdAt])
  @@index([questionId, createdAt])
  @@index([selectedOptionId])
  @@map("attempts")
}

model Exam {
  id            String   @id @default(uuid()) @db.Uuid
  createdAt     DateTime @default(now())
  startedAt     DateTime?
  finishedAt    DateTime?
  questionCount Int
  onlyUnsolved  Boolean  @default(false)
  filterSkillIds String[]

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  examBoardId String?    @db.Uuid
  examBoard   ExamBoard? @relation(fields: [examBoardId], references: [id], onDelete: SetNull)

  questions ExamQuestion[]
  attempts  Attempt[]

  @@index([userId, createdAt])
  @@index([examBoardId])
  @@map("exams")
}

model ExamQuestion {
  order Int

  examId String @db.Uuid
  exam   Exam   @relation(fields: [examId], references: [id], onDelete: Cascade)

  questionId String   @db.Uuid
  question   Question @relation(fields: [questionId], references: [id], onDelete: Restrict)

  @@id([examId, questionId])
  @@index([examId, order])
  @@map("exam_questions")
}

model ExamBoard {
  id      String @id @default(uuid()) @db.Uuid
  name    String
  logoUrl String

  exams      Exam[]
  examBases  ExamBase[]

  @@map("exam_boards")
}

model ExamBase {
  id                      String           @id @default(uuid()) @db.Uuid
  name                    String
  institution             String?
  role                    String
  governmentScope         GovernmentScope
  state                   String?
  city                    String?
  salaryBase              Decimal?         @db.Decimal(10,2)
  examDate                DateTime
  minPassingGradeNonQuota Decimal?         @db.Decimal(5,2)

  examBoardId String?    @db.Uuid
  examBoard   ExamBoard? @relation(fields: [examBoardId], references: [id], onDelete: SetNull)

  questions         ExamBaseQuestion[]
  attempts          ExamBaseAttempt[]
  trainingSessions  TrainingSession[]

  @@index([examBoardId])
  @@map("exam_bases")
}

model ExamBaseQuestion {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ligação com a base (prova)
  examBaseId String   @db.Uuid
  examBase   ExamBase @relation(fields: [examBaseId], references: [id], onDelete: Cascade)

  subject   String?
  topic     String?
  subtopics String[] @default([])

  statement String

  // URL pública da imagem do enunciado (ex.: Google Cloud Storage)
  statementImageUrl String?

  // Texto de referência da prova (ex.: texto base compartilhado por várias questões)
  referenceText String?

  // Ex: "A", "B", "C", "D"
  correctAlternative String?

  // habilidades cobradas (string por enquanto)
  skills String[] @default([])

  alternatives          ExamBaseQuestionAlternative[]
  attemptAnswers        ExamBaseAttemptAnswer[]
  trainingRetryAnswers  TrainingRetryAnswer[]

  @@index([examBaseId])
  @@index([examBaseId, subject])
  @@index([examBaseId, topic])
  @@map("exam_base_questions")
}

model ExamBaseQuestionAlternative {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  examBaseQuestionId String           @db.Uuid
  examBaseQuestion   ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)

  // "A", "B", "C", "D"...
  key String

  text        String
  explanation String

  selectedInAnswers           ExamBaseAttemptAnswer[]
  selectedInTrainingRetryAnswers TrainingRetryAnswer[]

  @@unique([examBaseQuestionId, key])
  @@index([examBaseQuestionId])
  @@map("exam_base_question_alternatives")
}

model ExamBaseAttempt {
  id               String    @id @default(uuid()) @db.Uuid
  startedAt        DateTime  @default(now())
  finishedAt       DateTime?
  scorePercentage  Decimal?  @db.Decimal(5, 2)
  subjectFeedback  Json?

  examBaseId String   @db.Uuid
  examBase   ExamBase @relation(fields: [examBaseId], references: [id], onDelete: Cascade)

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  answers          ExamBaseAttemptAnswer[]
  trainingSession  TrainingSession?
  subjectFeedbacks SubjectFeedback[]

  @@index([examBaseId])
  @@index([userId])
  @@map("exam_base_attempts")
}

model ExamBaseAttemptAnswer {
  examBaseAttemptId  String   @db.Uuid
  examBaseAttempt    ExamBaseAttempt @relation(fields: [examBaseAttemptId], references: [id], onDelete: Cascade)

  examBaseQuestionId String   @db.Uuid
  examBaseQuestion   ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)

  selectedAlternativeId String? @db.Uuid
  selectedAlternative   ExamBaseQuestionAlternative? @relation(fields: [selectedAlternativeId], references: [id], onDelete: SetNull)

  @@id([examBaseAttemptId, examBaseQuestionId])
  @@index([examBaseAttemptId])
  @@index([examBaseQuestionId])
  @@map("exam_base_attempt_answers")
}

// ---- Training (Treino) ----

enum TrainingStage {
  EXAM
  DIAGNOSIS
  STUDY
  RETRY
  FINAL
}

/// One training cycle: exam -> diagnosis -> study -> retry -> final. Tied to one ExamBaseAttempt.
model TrainingSession {
  id                    String         @id @default(uuid()) @db.Uuid
  currentStage          TrainingStage  @default(EXAM)
  finalScorePercentage  Decimal?       @db.Decimal(5, 2)
  finalFeedback         String?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  userId             String   @db.Uuid
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  examBaseAttemptId  String   @unique @db.Uuid
  examBaseAttempt    ExamBaseAttempt @relation(fields: [examBaseAttemptId], references: [id], onDelete: Cascade)
  examBaseId         String   @db.Uuid
  examBase           ExamBase @relation(fields: [examBaseId], references: [id], onDelete: Cascade)

  trainingRetries     TrainingRetry[]
  trainingStudyItems TrainingStudyItem[]

  @@index([userId])
  @@index([examBaseId])
  @@map("training_sessions")
}

/// One retry attempt: user answers (again) the questions they got wrong in the exam. Session can have multiple retries in the future.
model TrainingRetry {
  id                 String    @id @default(uuid()) @db.Uuid
  trainingSessionId  String    @db.Uuid
  trainingSession    TrainingSession @relation(fields: [trainingSessionId], references: [id], onDelete: Cascade)
  createdAt          DateTime  @default(now())
  finishedAt        DateTime? @db.Timestamp(3)

  retryAnswers       TrainingRetryAnswer[]

  @@index([trainingSessionId])
  @@map("training_retries")
}

model TrainingRetryAnswer {
  trainingRetryId      String   @db.Uuid
  trainingRetry        TrainingRetry @relation(fields: [trainingRetryId], references: [id], onDelete: Cascade)
  examBaseQuestionId   String   @db.Uuid
  examBaseQuestion     ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)
  selectedAlternativeId String  @db.Uuid
  selectedAlternative   ExamBaseQuestionAlternative @relation(fields: [selectedAlternativeId], references: [id], onDelete: Restrict)

  @@id([trainingRetryId, examBaseQuestionId])
  @@index([trainingRetryId])
  @@index([examBaseQuestionId])
  @@map("training_retry_answers")
}

/// One row per (attempt, subject): AI-generated evaluation. Recommendations are in SubjectFeedbackRecommendation.
model SubjectFeedback {
  id               String   @id @default(uuid()) @db.Uuid
  examBaseAttemptId String   @db.Uuid
  examBaseAttempt   ExamBaseAttempt @relation(fields: [examBaseAttemptId], references: [id], onDelete: Cascade)
  subject          String
  evaluation       String   @db.Text
  createdAt        DateTime @default(now())

  recommendations  SubjectFeedbackRecommendation[]

  @@unique([examBaseAttemptId, subject])
  @@index([examBaseAttemptId])
  @@map("subject_feedbacks")
}

/// One recommendation per subject feedback: title + deeper text (AI-generated).
model SubjectFeedbackRecommendation {
  id                 String   @id @default(uuid()) @db.Uuid
  subjectFeedbackId  String   @db.Uuid
  subjectFeedback    SubjectFeedback @relation(fields: [subjectFeedbackId], references: [id], onDelete: Cascade)
  title               String   @db.VarChar(500)
  text                String   @db.Text
  order               Int      @default(0)
  createdAt           DateTime @default(now())

  trainingStudyItems TrainingStudyItem[]

  @@index([subjectFeedbackId])
  @@map("subject_feedback_recommendations")
}

/// One per SubjectFeedbackRecommendation per TrainingSession: study item for a single recommendation (explanation + 5 exercises AI-generated).
model TrainingStudyItem {
  id                          String    @id @default(uuid()) @db.Uuid
  trainingSessionId           String    @db.Uuid
  trainingSession             TrainingSession @relation(fields: [trainingSessionId], references: [id], onDelete: Cascade)
  subjectFeedbackRecommendationId String    @db.Uuid
  subjectFeedbackRecommendation   SubjectFeedbackRecommendation @relation(fields: [subjectFeedbackRecommendationId], references: [id], onDelete: Cascade)
  subject                     String
  topic                       String?
  explanation                 String?   @db.Text
  completedAt                 DateTime?
  createdAt                   DateTime  @default(now())
  updatedAt                   DateTime  @updatedAt

  exercises StudyExercise[]

  @@unique([trainingSessionId, subjectFeedbackRecommendationId])
  @@index([trainingSessionId])
  @@index([subjectFeedbackRecommendationId])
  @@map("training_study_items")
}

/// One of 5 exercises per TrainingStudyItem (AI-generated).
model StudyExercise {
  id                    String   @id @default(uuid()) @db.Uuid
  trainingStudyItemId   String   @db.Uuid
  trainingStudyItem     TrainingStudyItem @relation(fields: [trainingStudyItemId], references: [id], onDelete: Cascade)
  order                 Int
  statement             String   @db.Text
  correctAlternativeKey String
  createdAt             DateTime @default(now())

  alternatives StudyExerciseAlternative[]

  @@index([trainingStudyItemId])
  @@map("study_exercises")
}

model StudyExerciseAlternative {
  id              String        @id @default(uuid()) @db.Uuid
  studyExerciseId String        @db.Uuid
  studyExercise   StudyExercise @relation(fields: [studyExerciseId], references: [id], onDelete: Cascade)
  key             String
  text            String        @db.Text
  isCorrect       Boolean
  createdAt       DateTime      @default(now())

  @@unique([studyExerciseId, key])
  @@index([studyExerciseId])
  @@map("study_exercise_alternatives")
}

// ---- Billing / Payments ----

/// One-time purchase granting platform access (e.g. 1 year). One purchase = one access period.
/// Used to determine if the user has active access (accessExpiresAt > now and refundedAt is null).
/// stripeChargeId is required to create a refund (e.g. for the 7-day right of withdrawal).
model Purchase {
  id                   String    @id @default(uuid()) @db.Uuid
  userId               String    @db.Uuid
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripeSessionId      String?
  stripePaymentIntentId String?
  stripeChargeId       String?
  purchasedAt          DateTime  @default(now())
  accessExpiresAt      DateTime
  refundedAt          DateTime?

  refundRequests RefundRequest[]

  @@index([userId])
  @@index([accessExpiresAt])
  @@map("purchases")
}

/// Webhook events from payment gateways (e.g. Stripe). Used for idempotency: we store each
/// event by (gateway, externalEventId) and skip processing if already seen, so retries do not
/// create duplicate purchases or double-apply refunds.
model PaymentEvent {
  id               String   @id @default(uuid()) @db.Uuid
  gateway          String
  externalEventId  String
  type             String
  processedAt      DateTime @default(now())
  payload          Json?

  @@unique([gateway, externalEventId])
  @@index([gateway])
  @@map("payment_events")
}

/// Record of a user requesting a refund (e.g. 7-day right of withdrawal / CDC). Tied to a
/// Purchase; once status is completed we do not allow another refund for the same purchase.
/// Keeps an audit trail and supports “already requested refund” checks in the API.
model RefundRequest {
  id           String    @id @default(uuid()) @db.Uuid
  userId       String    @db.Uuid
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  purchaseId   String    @db.Uuid
  purchase     Purchase  @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  requestedAt  DateTime  @default(now())
  reason       String?
  stripeRefundId String?
  status       String    // pending | completed | failed

  @@index([userId])
  @@index([purchaseId])
  @@map("refund_requests")
}
