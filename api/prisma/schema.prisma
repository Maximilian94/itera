generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---- User Roles & Subscription ----

/// User role on the platform. ADMIN has full access; USER is the default for everyone else.
enum UserRole {
  ADMIN
  USER
}

/// Subscription plan chosen by the user. ESSENCIAL: unlimited exams, explanations, history. ESTRATEGICO: everything in Essencial + up to 5 smart trainings/month. ELITE: everything in Estratégico + up to 20 trainings/month.
enum SubscriptionPlan {
  ESSENCIAL
  ESTRATEGICO
  ELITE
}

/// Stripe subscription status synced via webhooks. ACTIVE: payment up to date. PAST_DUE: charge failed. CANCELED: cancelled. INCOMPLETE: checkout not finished.
enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
}

enum GovernmentScope {
  MUNICIPAL
  STATE
  FEDERAL
}

model User {
  id               String    @id @default(uuid()) @db.Uuid
  email            String    @unique
  clerkUserId      String?   @unique
  /// Phone number; required for checkout. Used to contact the user after a refund (e.g. for feedback).
  phone            String?
  /// Stripe Customer ID; set when the user completes checkout or when we create a customer for them.
  stripeCustomerId String?   @unique
  /// User role (ADMIN = full access, USER = default). Assigned manually for admins.
  role             UserRole  @default(USER)
  createdAt        DateTime  @default(now())

  attempts          Attempt[]
  exams             Exam[]
  examBaseAttempts  ExamBaseAttempt[]
  purchases         Purchase[]
  refundRequests    RefundRequest[]
  subscriptions     Subscription[]
  trainingSessions  TrainingSession[]

  @@map("users")
}

model Skill {
  id        String     @id @default(uuid()) @db.Uuid
  name      String
  createdAt DateTime   @default(now())

  // Path Enumeration (Materialized Path)
  // Stores the complete hierarchy (ex: "uuid1/uuid2/uuid3")
  path String @unique

  parentId  String?    @db.Uuid
  parent    Skill?     @relation("SkillHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  Skill[]    @relation("SkillHierarchy")

  questions Question[]

  @@map("skills")
  @@index([path])
}

model Question {
  id              String    @id @default(uuid()) @db.Uuid
  statement       String
  explanationText String
  createdAt       DateTime  @default(now())

  skillId String @db.Uuid
  skill   Skill  @relation(fields: [skillId], references: [id], onDelete: Restrict)

  options       Option[]
  attempts      Attempt[]
  examQuestions ExamQuestion[]

  @@index([skillId])
  @@map("questions")
}

model Option {
  id        String   @id @default(uuid()) @db.Uuid
  text      String
  isCorrect Boolean
  createdAt DateTime @default(now())

  questionId String   @db.Uuid
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  attempts Attempt[]

  @@index([questionId])
  @@map("options")
}

model Attempt {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  examId String? @db.Uuid
  exam   Exam?   @relation(fields: [examId], references: [id], onDelete: SetNull)

  questionId String   @db.Uuid
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  selectedOptionId String? @db.Uuid
  selectedOption   Option? @relation(fields: [selectedOptionId], references: [id], onDelete: Restrict)

  @@index([userId, createdAt])
  @@index([examId, createdAt])
  @@index([questionId, createdAt])
  @@index([selectedOptionId])
  @@map("attempts")
}

model Exam {
  id            String   @id @default(uuid()) @db.Uuid
  createdAt     DateTime @default(now())
  startedAt     DateTime?
  finishedAt    DateTime?
  questionCount Int
  onlyUnsolved  Boolean  @default(false)
  filterSkillIds String[]

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  examBoardId String?    @db.Uuid
  examBoard   ExamBoard? @relation(fields: [examBoardId], references: [id], onDelete: SetNull)

  questions ExamQuestion[]
  attempts  Attempt[]

  @@index([userId, createdAt])
  @@index([examBoardId])
  @@map("exams")
}

model ExamQuestion {
  order Int

  examId String @db.Uuid
  exam   Exam   @relation(fields: [examId], references: [id], onDelete: Cascade)

  questionId String   @db.Uuid
  question   Question @relation(fields: [questionId], references: [id], onDelete: Restrict)

  @@id([examId, questionId])
  @@index([examId, order])
  @@map("exam_questions")
}

model ExamBoard {
  id         String  @id @default(uuid()) @db.Uuid
  name       String
  alias      String?
  websiteUrl String?
  logoUrl    String

  exams      Exam[]
  examBases  ExamBase[]

  @@map("exam_boards")
}

model ExamBase {
  id                      String           @id @default(uuid()) @db.Uuid
  name                    String
  slug                    String?          @unique
  institution             String?
  role                    String
  governmentScope         GovernmentScope
  state                   String?
  city                    String?
  salaryBase              Decimal?         @db.Decimal(10,2)
  examDate                DateTime
  minPassingGradeNonQuota Decimal?         @db.Decimal(5,2)
  /// When false, exam is only visible to admins. When true, visible to all users.
  published               Boolean          @default(false)

  examBoardId String?    @db.Uuid
  examBoard   ExamBoard? @relation(fields: [examBoardId], references: [id], onDelete: SetNull)

  questions         ExamBaseQuestion[]
  attempts          ExamBaseAttempt[]
  trainingSessions  TrainingSession[]

  @@index([examBoardId])
  @@map("exam_bases")
}

model ExamBaseQuestion {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ligação com a base (prova)
  examBaseId String   @db.Uuid
  examBase   ExamBase @relation(fields: [examBaseId], references: [id], onDelete: Cascade)

  subject   String?
  topic     String?
  subtopics String[] @default([])

  statement String

  // URL pública da imagem do enunciado (ex.: Google Cloud Storage)
  statementImageUrl String?

  // Texto de referência da prova (ex.: texto base compartilhado por várias questões)
  referenceText String?

  // Ex: "A", "B", "C", "D"
  correctAlternative String?

  // habilidades cobradas (string por enquanto)
  skills String[] @default([])

  // Posição na prova (0-based)
  position Int @default(0) @map("order")

  alternatives          ExamBaseQuestionAlternative[]
  attemptAnswers        ExamBaseAttemptAnswer[]
  trainingRetryAnswers  TrainingRetryAnswer[]
  studyItemQuestionLinks TrainingStudyItemQuestionLink[]
  recommendationQuestionLinks SubjectFeedbackRecommendationQuestionLink[]

  @@index([examBaseId])
  @@index([examBaseId, position])
  @@index([examBaseId, subject])
  @@index([examBaseId, topic])
  @@map("exam_base_questions")
}

model ExamBaseQuestionAlternative {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  examBaseQuestionId String           @db.Uuid
  examBaseQuestion   ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)

  // "A", "B", "C", "D"...
  key String

  text        String
  explanation String

  selectedInAnswers           ExamBaseAttemptAnswer[]
  selectedInTrainingRetryAnswers TrainingRetryAnswer[]
  selectedInStudyItemQuestionLinks TrainingStudyItemQuestionLink[]

  @@unique([examBaseQuestionId, key])
  @@index([examBaseQuestionId])
  @@map("exam_base_question_alternatives")
}

model ExamBaseAttempt {
  id               String    @id @default(uuid()) @db.Uuid
  startedAt        DateTime  @default(now())
  finishedAt       DateTime?
  scorePercentage  Decimal?  @db.Decimal(5, 2)
  subjectFeedback  Json?

  examBaseId String   @db.Uuid
  examBase   ExamBase @relation(fields: [examBaseId], references: [id], onDelete: Cascade)

  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  answers          ExamBaseAttemptAnswer[]
  trainingSession  TrainingSession?
  subjectFeedbacks SubjectFeedback[]

  @@index([examBaseId])
  @@index([userId])
  @@map("exam_base_attempts")
}

model ExamBaseAttemptAnswer {
  examBaseAttemptId  String   @db.Uuid
  examBaseAttempt    ExamBaseAttempt @relation(fields: [examBaseAttemptId], references: [id], onDelete: Cascade)

  examBaseQuestionId String   @db.Uuid
  examBaseQuestion   ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)

  selectedAlternativeId String? @db.Uuid
  selectedAlternative   ExamBaseQuestionAlternative? @relation(fields: [selectedAlternativeId], references: [id], onDelete: SetNull)

  @@id([examBaseAttemptId, examBaseQuestionId])
  @@index([examBaseAttemptId])
  @@index([examBaseQuestionId])
  @@map("exam_base_attempt_answers")
}

// ---- Training (Treino) ----

enum TrainingStage {
  EXAM
  DIAGNOSIS
  STUDY
  RETRY
  FINAL
}

/// One training cycle: exam -> diagnosis -> study -> retry -> final. Tied to one ExamBaseAttempt.
model TrainingSession {
  id                    String         @id @default(uuid()) @db.Uuid
  currentStage          TrainingStage  @default(EXAM)
  finalScorePercentage  Decimal?       @db.Decimal(5, 2)
  finalFeedback         String?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  userId             String   @db.Uuid
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  examBaseAttemptId  String   @unique @db.Uuid
  examBaseAttempt    ExamBaseAttempt @relation(fields: [examBaseAttemptId], references: [id], onDelete: Cascade)
  examBaseId         String   @db.Uuid
  examBase           ExamBase @relation(fields: [examBaseId], references: [id], onDelete: Cascade)

  trainingRetries     TrainingRetry[]
  trainingStudyItems TrainingStudyItem[]

  @@index([userId])
  @@index([examBaseId])
  @@map("training_sessions")
}

/// One retry attempt: user answers (again) the questions they got wrong in the exam. Session can have multiple retries in the future.
model TrainingRetry {
  id                 String    @id @default(uuid()) @db.Uuid
  trainingSessionId  String    @db.Uuid
  trainingSession    TrainingSession @relation(fields: [trainingSessionId], references: [id], onDelete: Cascade)
  createdAt          DateTime  @default(now())
  finishedAt        DateTime? @db.Timestamp(3)

  retryAnswers       TrainingRetryAnswer[]

  @@index([trainingSessionId])
  @@map("training_retries")
}

model TrainingRetryAnswer {
  trainingRetryId      String   @db.Uuid
  trainingRetry        TrainingRetry @relation(fields: [trainingRetryId], references: [id], onDelete: Cascade)
  examBaseQuestionId   String   @db.Uuid
  examBaseQuestion     ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)
  selectedAlternativeId String  @db.Uuid
  selectedAlternative   ExamBaseQuestionAlternative @relation(fields: [selectedAlternativeId], references: [id], onDelete: Restrict)

  @@id([trainingRetryId, examBaseQuestionId])
  @@index([trainingRetryId])
  @@index([examBaseQuestionId])
  @@map("training_retry_answers")
}

/// One row per (attempt, subject): AI-generated evaluation. Recommendations are in SubjectFeedbackRecommendation.
model SubjectFeedback {
  id               String   @id @default(uuid()) @db.Uuid
  examBaseAttemptId String   @db.Uuid
  examBaseAttempt   ExamBaseAttempt @relation(fields: [examBaseAttemptId], references: [id], onDelete: Cascade)
  subject          String
  evaluation       String   @db.Text
  createdAt        DateTime @default(now())

  recommendations  SubjectFeedbackRecommendation[]

  @@unique([examBaseAttemptId, subject])
  @@index([examBaseAttemptId])
  @@map("subject_feedbacks")
}

/// One recommendation per subject feedback: title + deeper text (AI-generated).
model SubjectFeedbackRecommendation {
  id                 String   @id @default(uuid()) @db.Uuid
  subjectFeedbackId  String   @db.Uuid
  subjectFeedback    SubjectFeedback @relation(fields: [subjectFeedbackId], references: [id], onDelete: Cascade)
  title               String   @db.VarChar(500)
  text                String   @db.Text
  order               Int      @default(0)
  createdAt           DateTime @default(now())

  trainingStudyItems TrainingStudyItem[]
  questionLinks      SubjectFeedbackRecommendationQuestionLink[]

  @@index([subjectFeedbackId])
  @@map("subject_feedback_recommendations")
}

/// Links which wrong questions from the attempt are related to each recommendation (AI-determined).
model SubjectFeedbackRecommendationQuestionLink {
  subjectFeedbackRecommendationId String   @db.Uuid
  subjectFeedbackRecommendation   SubjectFeedbackRecommendation @relation(fields: [subjectFeedbackRecommendationId], references: [id], onDelete: Cascade)
  examBaseQuestionId               String   @db.Uuid
  examBaseQuestion                 ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)

  @@id([subjectFeedbackRecommendationId, examBaseQuestionId])
  @@index([subjectFeedbackRecommendationId])
  @@index([examBaseQuestionId])
  @@map("subject_feedback_recommendation_question_links")
}

/// One per SubjectFeedbackRecommendation per TrainingSession: study item for a single recommendation (explanation + 5 exercises AI-generated).
model TrainingStudyItem {
  id                          String    @id @default(uuid()) @db.Uuid
  trainingSessionId           String    @db.Uuid
  trainingSession             TrainingSession @relation(fields: [trainingSessionId], references: [id], onDelete: Cascade)
  subjectFeedbackRecommendationId String    @db.Uuid
  subjectFeedbackRecommendation   SubjectFeedbackRecommendation @relation(fields: [subjectFeedbackRecommendationId], references: [id], onDelete: Cascade)
  subject                     String
  topic                       String?
  explanation                 String?   @db.Text
  completedAt                 DateTime?
  createdAt                   DateTime  @default(now())
  updatedAt                   DateTime  @updatedAt

  exercises StudyExercise[]
  questionLinks TrainingStudyItemQuestionLink[]

  @@unique([trainingSessionId, subjectFeedbackRecommendationId])
  @@index([trainingSessionId])
  @@index([subjectFeedbackRecommendationId])
  @@map("training_study_items")
}

/// Links which wrong questions from the original attempt are related to a study item recommendation.
model TrainingStudyItemQuestionLink {
  trainingStudyItemId String @db.Uuid
  trainingStudyItem   TrainingStudyItem @relation(fields: [trainingStudyItemId], references: [id], onDelete: Cascade)

  examBaseQuestionId String @db.Uuid
  examBaseQuestion   ExamBaseQuestion @relation(fields: [examBaseQuestionId], references: [id], onDelete: Cascade)

  // Snapshot of what the user selected in the original attempt for this question.
  selectedAlternativeId String? @db.Uuid
  selectedAlternative   ExamBaseQuestionAlternative? @relation(fields: [selectedAlternativeId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@id([trainingStudyItemId, examBaseQuestionId])
  @@index([trainingStudyItemId])
  @@index([examBaseQuestionId])
  @@map("training_study_item_question_links")
}

/// One of 5 exercises per TrainingStudyItem (AI-generated).
model StudyExercise {
  id                    String   @id @default(uuid()) @db.Uuid
  trainingStudyItemId   String   @db.Uuid
  trainingStudyItem     TrainingStudyItem @relation(fields: [trainingStudyItemId], references: [id], onDelete: Cascade)
  order                 Int
  statement             String   @db.Text
  correctAlternativeKey String
  createdAt             DateTime @default(now())

  alternatives StudyExerciseAlternative[]

  @@index([trainingStudyItemId])
  @@map("study_exercises")
}

model StudyExerciseAlternative {
  id              String        @id @default(uuid()) @db.Uuid
  studyExerciseId String        @db.Uuid
  studyExercise   StudyExercise @relation(fields: [studyExerciseId], references: [id], onDelete: Cascade)
  key             String
  text            String        @db.Text
  isCorrect       Boolean
  createdAt       DateTime      @default(now())

  @@unique([studyExerciseId, key])
  @@index([studyExerciseId])
  @@map("study_exercise_alternatives")
}

// ---- Billing / Subscriptions ----

/// Recurring subscription for the user. Source of truth for platform access. Synced via Stripe webhooks (checkout.session.completed, customer.subscription.updated, etc.). A user can have multiple Subscriptions over time, but only one ACTIVE at a time.
model Subscription {
  id                    String             @id @default(uuid()) @db.Uuid
  /// User who owns the subscription.
  userId                String             @db.Uuid
  user                  User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// Stripe subscription ID (sub_xxx). Used for lookups and cancellations.
  stripeSubscriptionId  String             @unique
  /// Stripe customer ID (cus_xxx). Denormalized for easier lookups.
  stripeCustomerId      String
  /// Stripe price ID (price_xxx). Indicates plan + billing interval (monthly/yearly).
  stripePriceId         String
  /// Subscribed plan (ESSENCIAL, ESTRATEGICO, ELITE).
  plan                  SubscriptionPlan
  /// Current subscription status, synced via webhooks.
  status                SubscriptionStatus
  /// Start of the current billing period.
  currentPeriodStart    DateTime
  /// End of the current billing period. After this date, it renews or expires.
  currentPeriodEnd      DateTime
  /// If true, the subscription will be cancelled at the end of the current period (no renewal).
  cancelAtPeriodEnd     Boolean            @default(false)
  /// Stripe subscription schedule ID (sub_sched_xxx) when a downgrade is scheduled for period end.
  stripeScheduleId      String?
  /// Plan that will take effect at the next billing period (downgrade scheduled).
  scheduledPlan         SubscriptionPlan?
  /// Stripe price ID that will take effect at the next billing period.
  scheduledPriceId      String?
  /// Billing interval (month/year) that will take effect at the next billing period.
  scheduledInterval     String?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  purchases Purchase[]

  @@index([userId])
  @@index([status])
  @@map("subscriptions")
}

/// Individual payment record (financial audit trail). Each recurring charge (monthly/yearly) creates a Purchase linked to its Subscription. Used for payment tracking, receipt generation, and refund control (CDC 7-day withdrawal).
model Purchase {
  id                    String        @id @default(uuid()) @db.Uuid
  /// User who made the payment.
  userId                String        @db.Uuid
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// Subscription this payment belongs to.
  subscriptionId        String?       @db.Uuid
  subscription          Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  /// Stripe invoice ID (in_xxx). Identifies the specific charge.
  stripeInvoiceId       String?       @unique
  /// Stripe PaymentIntent ID (pi_xxx).
  stripePaymentIntentId String?
  /// Stripe charge ID (ch_xxx). Required for creating refunds.
  stripeChargeId        String?
  /// Amount in cents (e.g. 4990 = R$ 49.90). Default 0 for legacy records.
  amount                Int           @default(0)
  /// ISO 4217 currency code (e.g. "brl").
  currency              String        @default("brl")
  purchasedAt           DateTime      @default(now())
  /// Date the payment was refunded. null = not refunded.
  refundedAt            DateTime?

  refundRequests RefundRequest[]

  @@index([userId])
  @@index([subscriptionId])
  @@map("purchases")
}

/// Webhook events from payment gateways (e.g. Stripe). Used for idempotency: we store each
/// event by (gateway, externalEventId) and skip processing if already seen, so retries do not
/// create duplicate purchases or double-apply refunds.
model PaymentEvent {
  id               String   @id @default(uuid()) @db.Uuid
  gateway          String
  externalEventId  String
  type             String
  processedAt      DateTime @default(now())
  payload          Json?

  @@unique([gateway, externalEventId])
  @@index([gateway])
  @@map("payment_events")
}

/// Record of a user requesting a refund (e.g. 7-day right of withdrawal / CDC). Tied to a
/// Purchase; once status is completed we do not allow another refund for the same purchase.
/// Keeps an audit trail and supports “already requested refund” checks in the API.
model RefundRequest {
  id           String    @id @default(uuid()) @db.Uuid
  userId       String    @db.Uuid
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  purchaseId   String    @db.Uuid
  purchase     Purchase  @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  requestedAt  DateTime  @default(now())
  reason       String?
  stripeRefundId String?
  status       String    // pending | completed | failed

  @@index([userId])
  @@index([purchaseId])
  @@map("refund_requests")
}
